import edu.ucr.cs.riple.taint.ucrtainting.qual.RUntainted;

package org.apache.commons.io.output;
public class FileWriterWithEncoding {
	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param file the file to write to, not null
	 * @param charsetName the name of the requested charset, not null
	 * @throws NullPointerException if the file or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final File file, @RUntainted final String charsetName) throws IOException {
	    this(file, charsetName, false);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param fileName the name of the file to write to, not null
	 * @param charsetEncoder the encoding to use, not null
	 * @param append true if content should be appended, false to overwrite
	 * @throws NullPointerException if the file name or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final String fileName, @RUntainted final CharsetEncoder charsetEncoder, final boolean append) throws IOException {
	    this(new File(fileName), charsetEncoder, append);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param file the file to write to, not null.
	 * @param charsetEncoder the encoding to use, null uses the default Charset.
	 * @param append true if content should be appended, false to overwrite.
	 * @throws NullPointerException if the file is null.
	 * @throws IOException in case of an I/O error.
	 */
	// Call site is responsible for closing a new instance.
	@SuppressWarnings("resource")
	public FileWriterWithEncoding(@RUntainted final File file, @RUntainted final CharsetEncoder charsetEncoder, final boolean append) throws IOException {
	    super(initWriter(file, charsetEncoder, append));
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param fileName the name of the file to write to, not null
	 * @param charsetName the name of the requested charset, not null
	 * @throws NullPointerException if the file name or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final String fileName, @RUntainted final String charsetName) throws IOException {
	    this(new File(fileName), charsetName, false);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param file the file to write to, not null
	 * @param charset the encoding to use, not null
	 * @throws NullPointerException if the file or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final File file, @RUntainted final Charset charset) throws IOException {
	    this(file, charset, false);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param file the file to write to, not null
	 * @param charsetEncoder the encoding to use, not null
	 * @throws NullPointerException if the file or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final File file, @RUntainted final CharsetEncoder charsetEncoder) throws IOException {
	    this(file, charsetEncoder, false);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param file the file to write to, not null.
	 * @param encoding the name of the requested charset, null uses the default Charset.
	 * @param append true if content should be appended, false to overwrite.
	 * @throws NullPointerException if the file is null.
	 * @throws IOException in case of an I/O error.
	 */
	// Call site is responsible for closing a new instance.
	@SuppressWarnings("resource")
	public FileWriterWithEncoding(@RUntainted final File file, @RUntainted final Charset encoding, final boolean append) throws IOException {
	    super(initWriter(file, encoding, append));
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param fileName the name of the file to write to, not null
	 * @param charset the charset to use, not null
	 * @throws NullPointerException if the file name or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final String fileName, @RUntainted final Charset charset) throws IOException {
	    this(new File(fileName), charset, false);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param fileName the name of the file to write to, not null
	 * @param charset the encoding to use, not null
	 * @param append true if content should be appended, false to overwrite
	 * @throws NullPointerException if the file name or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final String fileName, @RUntainted final Charset charset, final boolean append) throws IOException {
	    this(new File(fileName), charset, append);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param fileName the name of the file to write to, not null
	 * @param charsetName the name of the requested charset, not null
	 * @param append true if content should be appended, false to overwrite
	 * @throws NullPointerException if the file name or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final String fileName, @RUntainted final String charsetName, final boolean append) throws IOException {
	    this(new File(fileName), charsetName, append);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param fileName the name of the file to write to, not null
	 * @param encoding the encoding to use, not null
	 * @throws NullPointerException if the file name or encoding is null
	 * @throws IOException in case of an I/O error
	 */
	public FileWriterWithEncoding(@RUntainted final String fileName, @RUntainted final CharsetEncoder encoding) throws IOException {
	    this(new File(fileName), encoding, false);
	}

	/**
	 * Constructs a FileWriterWithEncoding with a file encoding.
	 *
	 * @param file the file to write to, not null.
	 * @param charsetName the name of the requested charset, null uses the default Charset.
	 * @param append true if content should be appended, false to overwrite.
	 * @throws NullPointerException if the file is null.
	 * @throws IOException in case of an I/O error.
	 */
	// Call site is responsible for closing a new instance.
	@SuppressWarnings("resource")
	public FileWriterWithEncoding(@RUntainted final File file, @RUntainted final String charsetName, final boolean append) throws IOException {
	    super(initWriter(file, charsetName, append));
	}

}
package org.apache.commons.io.output;
public class DeferredFileOutputStream {
	/**
	 * Constructs an instance of this class which will trigger an event at the specified threshold, and save data to a
	 * temporary file beyond that point.
	 *
	 * @param threshold The number of bytes at which to trigger an event.
	 * @param initialBufferSize The initial size of the in memory buffer.
	 * @param prefix Prefix to use for the temporary file.
	 * @param suffix Suffix to use for the temporary file.
	 * @param directory Temporary file directory.
	 *
	 * @since 2.5
	 */
	public DeferredFileOutputStream(final int threshold, final int initialBufferSize, @RUntainted final String prefix, @RUntainted final String suffix, @RUntainted final File directory) {
	    this(threshold, null, prefix, suffix, directory, initialBufferSize);
	    Objects.requireNonNull(prefix, "prefix");
	    if (initialBufferSize < 0) {
	        throw new IllegalArgumentException("Initial buffer size must be at least 0.");
	    }
	}

	/**
	 * Constructs an instance of this class which will trigger an event at the specified threshold, and save data either
	 * to a file beyond that point.
	 *
	 * @param threshold The number of bytes at which to trigger an event.
	 * @param outputFile The file to which data is saved beyond the threshold.
	 * @param prefix Prefix to use for the temporary file.
	 * @param suffix Suffix to use for the temporary file.
	 * @param directory Temporary file directory.
	 * @param initialBufferSize The initial size of the in memory buffer.
	 */
	private DeferredFileOutputStream(final int threshold, @RUntainted final File outputFile, @RUntainted final String prefix, @RUntainted final String suffix, @RUntainted final File directory, final int initialBufferSize) {
	    super(threshold);
	    this.outputPath = toPath(outputFile, null);
	    this.prefix = prefix;
	    this.suffix = suffix;
	    this.directory = toPath(directory, PathUtils::getTempDirectory);
	    memoryOutputStream = new ByteArrayOutputStream(initialBufferSize);
	    currentOutputStream = memoryOutputStream;
	}

	/**
	 * Constructs an instance of this class which will trigger an event at the specified threshold, and save data to a
	 * temporary file beyond that point. The initial buffer size will default to 32 bytes which is
	 * ByteArrayOutputStream's default buffer size.
	 *
	 * @param threshold The number of bytes at which to trigger an event.
	 * @param prefix Prefix to use for the temporary file.
	 * @param suffix Suffix to use for the temporary file.
	 * @param directory Temporary file directory.
	 *
	 * @since 1.4
	 */
	public DeferredFileOutputStream(final int threshold, @RUntainted final String prefix, @RUntainted final String suffix, @RUntainted final File directory) {
	    this(threshold, null, prefix, suffix, directory, AbstractByteArrayOutputStream.DEFAULT_SIZE);
	    Objects.requireNonNull(prefix, "prefix");
	}

	/**
	 * Constructs an instance of this class which will trigger an event at the specified threshold, and save data to a
	 * file beyond that point.
	 *
	 * @param threshold The number of bytes at which to trigger an event.
	 * @param initialBufferSize The initial size of the in memory buffer.
	 * @param outputFile The file to which data is saved beyond the threshold.
	 *
	 * @since 2.5
	 */
	public DeferredFileOutputStream(final int threshold, final int initialBufferSize, @RUntainted final File outputFile) {
	    this(threshold, outputFile, null, null, null, initialBufferSize);
	    if (initialBufferSize < 0) {
	        throw new IllegalArgumentException("Initial buffer size must be at least 0.");
	    }
	}

	/**
	 * Constructs an instance of this class which will trigger an event at the specified threshold, and save data to a
	 * file beyond that point. The initial buffer size will default to
	 * {@value AbstractByteArrayOutputStream#DEFAULT_SIZE} bytes which is ByteArrayOutputStream's default buffer size.
	 *
	 * @param threshold The number of bytes at which to trigger an event.
	 * @param outputFile The file to which data is saved beyond the threshold.
	 */
	public DeferredFileOutputStream(final int threshold, @RUntainted final File outputFile) {
	    this(threshold, outputFile, null, null, null, AbstractByteArrayOutputStream.DEFAULT_SIZE);
	}

}

package org.apache.commons.io.output;
public class LockableFileWriter {
	/**
	 * Constructs a LockableFileWriter.
	 *
	 * @param file  the file to write to, not null
	 * @param append  true if content should be appended, false to overwrite
	 * @param lockDir  the directory in which the lock file should be held
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 * @deprecated 2.5 use {@link #LockableFileWriter(File, Charset, boolean, String)} instead
	 */
	@Deprecated
	public LockableFileWriter(@RUntainted final File file, final boolean append, @RUntainted final String lockDir) throws IOException {
	    this(file, Charset.defaultCharset(), append, lockDir);
	}

	/**
	 * Constructs a LockableFileWriter with a file encoding.
	 *
	 * @param file  the file to write to, not null
	 * @param charset  the name of the requested charset, null means platform default
	 * @param append  true if content should be appended, false to overwrite
	 * @param lockDir  the directory in which the lock file should be held
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 * @since 2.3
	 */
	public LockableFileWriter(@RUntainted final File file, @RUntainted final Charset charset, final boolean append, @RUntainted String lockDir) throws IOException {
	    // init file to create/append
	    final File absFile = file.getAbsoluteFile();
	    if (absFile.getParentFile() != null) {
	        FileUtils.forceMkdir(absFile.getParentFile());
	    }
	    if (absFile.isDirectory()) {
	        throw new IOException("File specified is a directory");
	    }
	    // init lock file
	    if (lockDir == null) {
	        lockDir = FileUtils.getTempDirectoryPath();
	    }
	    final File lockDirFile = new File(lockDir);
	    FileUtils.forceMkdir(lockDirFile);
	    testLockDir(lockDirFile);
	    lockFile = new File(lockDirFile, absFile.getName() + LCK);
	    // check if locked
	    createLock();
	    // init wrapped writer
	    out = initWriter(absFile, charset, append);
	}

	/**
	 * Constructs a LockableFileWriter.
	 *
	 * @param fileName  the file to write to, not null
	 * @param append  true if content should be appended, false to overwrite
	 * @param lockDir  the directory in which the lock file should be held
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 */
	public LockableFileWriter(@RUntainted final String fileName, final boolean append, @RUntainted final String lockDir) throws IOException {
	    this(new File(fileName), append, lockDir);
	}

	/**
	 * Constructs a LockableFileWriter.
	 * If the file exists, it is overwritten.
	 *
	 * @param file  the file to write to, not null
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 */
	public LockableFileWriter(@RUntainted final File file) throws IOException {
	    this(file, false, null);
	}

	/**
	 * Constructs a LockableFileWriter with a file encoding.
	 *
	 * @param file  the file to write to, not null
	 * @param charsetName  the name of the requested charset, null means platform default
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 * @throws java.nio.charset.UnsupportedCharsetException
	 *             thrown instead of {@link java.io.UnsupportedEncodingException} in version 2.2 if the encoding is not
	 *             supported.
	 */
	public LockableFileWriter(@RUntainted final File file, @RUntainted final String charsetName) throws IOException {
	    this(file, charsetName, false, null);
	}

	/**
	 * Constructs a LockableFileWriter with a file encoding.
	 *
	 * @param file  the file to write to, not null
	 * @param charsetName  the encoding to use, null means platform default
	 * @param append  true if content should be appended, false to overwrite
	 * @param lockDir  the directory in which the lock file should be held
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 * @throws java.nio.charset.UnsupportedCharsetException
	 *             thrown instead of {@link java.io.UnsupportedEncodingException} in version 2.2 if the encoding is not
	 *             supported.
	 */
	public LockableFileWriter(@RUntainted final File file, @RUntainted final String charsetName, final boolean append, @RUntainted final String lockDir) throws IOException {
	    this(file, Charsets.toCharset(charsetName), append, lockDir);
	}

	/**
	 * Constructs a LockableFileWriter.
	 * If the file exists, it is overwritten.
	 *
	 * @param fileName  the file to write to, not null
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 */
	public LockableFileWriter(@RUntainted final String fileName) throws IOException {
	    this(fileName, false, null);
	}

	/**
	 * Constructs a LockableFileWriter.
	 *
	 * @param file  the file to write to, not null
	 * @param append  true if content should be appended, false to overwrite
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 */
	public LockableFileWriter(@RUntainted final File file, final boolean append) throws IOException {
	    this(file, append, null);
	}

	/**
	 * Constructs a LockableFileWriter.
	 *
	 * @param fileName  file to write to, not null
	 * @param append  true if content should be appended, false to overwrite
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 */
	public LockableFileWriter(@RUntainted final String fileName, final boolean append) throws IOException {
	    this(fileName, append, null);
	}

	/**
	 * Constructs a LockableFileWriter with a file encoding.
	 *
	 * @param file  the file to write to, not null
	 * @param charset  the charset to use, null means platform default
	 * @throws NullPointerException if the file is null
	 * @throws IOException in case of an I/O error
	 * @since 2.3
	 */
	public LockableFileWriter(@RUntainted final File file, @RUntainted final Charset charset) throws IOException {
	    this(file, charset, false, null);
	}

}

package org.apache.commons.io;
public class FileUtils {
	/**
	 * Copies a file to a directory preserving the file date.
	 * <p>
	 * This method copies the contents of the specified source file to a file of the same name in the specified
	 * destination directory. The destination directory is created if it does not exist. If the destination file exists,
	 * then this method will overwrite it.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This method tries to preserve the file's last modified date/times using
	 * {@link StandardCopyOption#COPY_ATTRIBUTES}, however it is not guaranteed that the operation will succeed. If the
	 * modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param srcFile an existing file to copy, must not be {@code null}.
	 * @param destDir the directory to place the copy in, must not be {@code null}.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if source or destination is invalid.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @see #copyFile(File, File, boolean)
	 */
	public static void copyFileToDirectory(@RUntainted final File srcFile, @RUntainted final File destDir) throws IOException {
	    copyFileToDirectory(srcFile, destDir, true);
	}

	/**
	 * Writes the {@code toString()} value of each item in a collection to
	 * the specified {@link File} line by line.
	 * The specified character encoding and the default line ending will be used.
	 * <p>
	 * NOTE: As from v1.3, the parent directories of the file will be created
	 * if they do not exist.
	 * </p>
	 *
	 * @param file     the file to write to
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @param lines    the lines to write, {@code null} entries produce blank lines
	 * @throws IOException                          in case of an I/O error
	 * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
	 * @since 1.1
	 */
	public static void writeLines(@RUntainted final File file, @RUntainted final String charsetName, @RUntainted final Collection<?> lines) throws IOException {
	    writeLines(file, charsetName, lines, null, false);
	}

	/**
	 * Reads the contents of a file line by line to a List of Strings using the default encoding for the VM.
	 * The file is always closed.
	 *
	 * @param file the file to read, must not be {@code null}
	 * @return the list of Strings representing each line in the file, never {@code null}
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @since 1.3
	 * @deprecated 2.5 use {@link #readLines(File, Charset)} instead (and specify the appropriate encoding)
	 */
	@Deprecated
	public static List<String> readLines(@RUntainted final File file) throws IOException {
	    return readLines(file, Charset.defaultCharset());
	}

	/**
	 * Moves a file or directory to the destination directory.
	 * <p>
	 * When the destination is on another file system, do a "copy and delete".
	 * </p>
	 *
	 * @param src the file or directory to be moved.
	 * @param destDir the destination directory.
	 * @param createDestDir If {@code true} create the destination directory, otherwise if {@code false} throw an
	 *        IOException.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws FileExistsException if the directory or file exists in the destination directory.
	 * @throws FileNotFoundException if the source file does not exist.
	 * @throws IOException if source or destination is invalid.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.4
	 */
	public static void moveToDirectory(@RUntainted final File src, @RUntainted final File destDir, final boolean createDestDir) throws IOException {
	    validateMoveParameters(src, destDir);
	    if (src.isDirectory()) {
	        moveDirectoryToDirectory(src, destDir, createDestDir);
	    } else {
	        moveFileToDirectory(src, destDir, createDestDir);
	    }
	}

	/**
	 * Opens a {@link FileOutputStream} for the specified file, checking and
	 * creating the parent directory if it does not exist.
	 * <p>
	 * At the end of the method either the stream will be successfully opened,
	 * or an exception will have been thrown.
	 * </p>
	 * <p>
	 * The parent directory will be created if it does not exist.
	 * The file will be created if it does not exist.
	 * An exception is thrown if the file object exists but is a directory.
	 * An exception is thrown if the file exists but cannot be written to.
	 * An exception is thrown if the parent directory cannot be created.
	 * </p>
	 *
	 * @param file   the file to open for output, must not be {@code null}
	 * @param append if {@code true}, then bytes will be added to the
	 *               end of the file rather than overwriting
	 * @return a new {@link FileOutputStream} for the specified file
	 * @throws NullPointerException if the file object is {@code null}.
	 * @throws IllegalArgumentException if the file object is a directory
	 * @throws IllegalArgumentException if the file is not writable.
	 * @throws IOException if the directories could not be created.
	 * @since 2.1
	 */
	public static FileOutputStream openOutputStream(@RUntainted final File file, final boolean append) throws IOException {
	    Objects.requireNonNull(file, "file");
	    if (file.exists()) {
	        requireFile(file, "file");
	        requireCanWrite(file, "file");
	    } else {
	        createParentDirectories(file);
	    }
	    return new FileOutputStream(file, append);
	}

	/**
	 * Copies a file to a directory optionally preserving the file date.
	 * <p>
	 * This method copies the contents of the specified source file to a file of the same name in the specified
	 * destination directory. The destination directory is created if it does not exist. If the destination file exists,
	 * then this method will overwrite it.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
	 * modified date/times using {@link StandardCopyOption#COPY_ATTRIBUTES}, however it is not guaranteed that the operation
	 * will succeed. If the modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param sourceFile an existing file to copy, must not be {@code null}.
	 * @param destinationDir the directory to place the copy in, must not be {@code null}.
	 * @param preserveFileDate true if the file date of the copy should be the same as the original.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @throws IOException if the output file length is not the same as the input file length after the copy completes.
	 * @see #copyFile(File, File, CopyOption...)
	 * @since 1.3
	 */
	public static void copyFileToDirectory(@RUntainted final File sourceFile, @RUntainted final File destinationDir, final boolean preserveFileDate) throws IOException {
	    Objects.requireNonNull(sourceFile, "sourceFile");
	    requireDirectoryIfExists(destinationDir, "destinationDir");
	    copyFile(sourceFile, new File(destinationDir, sourceFile.getName()), preserveFileDate);
	}

	/**
	 * Moves a directory to another directory.
	 *
	 * @param source the file to be moved.
	 * @param destDir the destination file.
	 * @param createDestDir If {@code true} create the destination directory, otherwise if {@code false} throw an
	 *        IOException.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.4
	 */
	public static void moveDirectoryToDirectory(@RUntainted final File source, @RUntainted final File destDir, final boolean createDestDir) throws IOException {
	    validateMoveParameters(source, destDir);
	    if (!destDir.isDirectory()) {
	        if (destDir.exists()) {
	            throw new IOException("Destination '" + destDir + "' is not a directory");
	        }
	        if (!createDestDir) {
	            throw new FileNotFoundException("Destination directory '" + destDir + "' does not exist [createDestDir=" + false + "]");
	        }
	        mkdirs(destDir);
	    }
	    moveDirectory(source, new File(destDir, source.getName()));
	}

	/**
	 * Writes a String to a file creating the file if it does not exist.
	 * <p>
	 * NOTE: As from v1.3, the parent directories of the file will be created
	 * if they do not exist.
	 * </p>
	 *
	 * @param file     the file to write
	 * @param data     the content to write to the file
	 * @param charset the charset to use, {@code null} means platform default
	 * @throws IOException                          in case of an I/O error
	 * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
	 * @since 2.4
	 */
	public static void writeStringToFile(@RUntainted final File file, @RUntainted final String data, @RUntainted final Charset charset) throws IOException {
	    writeStringToFile(file, data, charset, false);
	}

	/**
	 * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.
	 *
	 * @param file   the file to write
	 * @param data   the content to write to the file
	 * @param append if {@code true}, then the data will be added to the
	 *               end of the file rather than overwriting
	 * @throws IOException in case of an I/O error
	 * @since 2.1
	 * @deprecated 2.5 use {@link #write(File, CharSequence, Charset, boolean)} instead (and specify the appropriate encoding)
	 */
	@Deprecated
	public static void write(@RUntainted final File file, @RUntainted final CharSequence data, final boolean append) throws IOException {
	    write(file, data, Charset.defaultCharset(), append);
	}

	/**
	 * Reads the contents of a file into a String.
	 * The file is always closed.
	 *
	 * @param file     the file to read, must not be {@code null}
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @return the file contents, never {@code null}
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @since 2.3
	 */
	public static String readFileToString(@RUntainted final File file, @RUntainted final Charset charsetName) throws IOException {
	    try (InputStream inputStream = Files.newInputStream(file.toPath())) {
	        return IOUtils.toString(inputStream, Charsets.toCharset(charsetName));
	    }
	}

	/**
	 * Copies bytes from the URL {@code source} to a file {@code destination}. The directories up to
	 * {@code destination} will be created if they don't already exist. {@code destination} will be
	 * overwritten if it already exists.
	 *
	 * @param source the {@link URL} to copy bytes from, must not be {@code null}
	 * @param destination the non-directory {@link File} to write bytes to (possibly overwriting), must not be
	 *        {@code null}
	 * @param connectionTimeoutMillis the number of milliseconds until this method will time out if no connection could
	 *        be established to the {@code source}
	 * @param readTimeoutMillis the number of milliseconds until this method will time out if no data could be read from
	 *        the {@code source}
	 * @throws IOException if {@code source} URL cannot be opened
	 * @throws IOException if {@code destination} is a directory
	 * @throws IOException if {@code destination} cannot be written
	 * @throws IOException if {@code destination} needs creating but can't be
	 * @throws IOException if an IO error occurs during copying
	 * @since 2.0
	 */
	public static void copyURLToFile(@RUntainted final URL source, @RUntainted final File destination, final int connectionTimeoutMillis, final int readTimeoutMillis) throws IOException {
	    try (CloseableURLConnection urlConnection = CloseableURLConnection.open(source)) {
	        urlConnection.setConnectTimeout(connectionTimeoutMillis);
	        urlConnection.setReadTimeout(readTimeoutMillis);
	        try (InputStream stream = urlConnection.getInputStream()) {
	            copyInputStreamToFile(stream, destination);
	        }
	    }
	}

	/**
	 * Writes a CharSequence to a file creating the file if it does not exist.
	 *
	 * @param file     the file to write
	 * @param data     the content to write to the file
	 * @param charset the name of the requested charset, {@code null} means platform default
	 * @throws IOException in case of an I/O error
	 * @since 2.3
	 */
	public static void write(@RUntainted final File file, @RUntainted final CharSequence data, @RUntainted final Charset charset) throws IOException {
	    write(file, data, charset, false);
	}

	/**
	 * Copies a filtered directory to a new location.
	 * <p>
	 * This method copies the contents of the specified source directory to within the specified destination directory.
	 * </p>
	 * <p>
	 * The destination directory is created if it does not exist. If the destination directory did exist, then this
	 * method merges the source with the destination, with the source taking precedence.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the files' last
	 * modified date/times using {@link File#setLastModified(long)}, however it is not guaranteed that those operations
	 * will succeed. If the modification operation fails, the methods throws IOException.
	 * </p>
	 * <b>Example: Copy directories only</b>
	 *
	 * <pre>
	 * // only copy the directory structure
	 * FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY, false);
	 * </pre>
	 *
	 * <b>Example: Copy directories and txt files</b>
	 *
	 * <pre>
	 * // Create a filter for ".txt" files
	 * IOFileFilter txtSuffixFilter = FileFilterUtils.suffixFileFilter(".txt");
	 * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter);
	 *
	 * // Create a filter for either directories or ".txt" files
	 * FileFilter filter = FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles);
	 *
	 * // Copy using the filter
	 * FileUtils.copyDirectory(srcDir, destDir, filter, false);
	 * </pre>
	 *
	 * @param srcDir an existing directory to copy, must not be {@code null}.
	 * @param destDir the new directory, must not be {@code null}.
	 * @param filter the filter to apply, null means copy all directories and files.
	 * @param preserveFileDate true if the file date of the copy should be the same as the original.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.4
	 */
	public static void copyDirectory(@RUntainted final File srcDir, @RUntainted final File destDir, @RUntainted final FileFilter filter, final boolean preserveFileDate) throws IOException {
	    copyDirectory(srcDir, destDir, filter, preserveFileDate, StandardCopyOption.REPLACE_EXISTING);
	}

	/**
	 * Reads the contents of a file into a byte array.
	 * The file is always closed.
	 *
	 * @param file the file to read, must not be {@code null}
	 * @return the file contents, never {@code null}
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @since 1.1
	 */
	public static byte[] readFileToByteArray(@RUntainted final File file) throws IOException {
	    Objects.requireNonNull(file, "file");
	    return Files.readAllBytes(file.toPath());
	}

	/**
	 * Writes a String to a file creating the file if it does not exist.
	 *
	 * @param file     the file to write
	 * @param data     the content to write to the file
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @param append   if {@code true}, then the String will be added to the
	 *                 end of the file rather than overwriting
	 * @throws IOException                 in case of an I/O error
	 * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
	 * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported by the VM
	 * @since 2.1
	 */
	public static void writeStringToFile(@RUntainted final File file, @RUntainted final String data, @RUntainted final String charsetName, final boolean append) throws IOException {
	    writeStringToFile(file, data, Charsets.toCharset(charsetName), append);
	}

	/**
	 * Opens a {@link FileInputStream} for the specified file, providing better error messages than simply calling
	 * {@code new FileInputStream(file)}.
	 * <p>
	 * At the end of the method either the stream will be successfully opened, or an exception will have been thrown.
	 * </p>
	 * <p>
	 * An exception is thrown if the file does not exist. An exception is thrown if the file object exists but is a
	 * directory. An exception is thrown if the file exists but cannot be read.
	 * </p>
	 *
	 * @param file the file to open for input, must not be {@code null}
	 * @return a new {@link FileInputStream} for the specified file
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException See FileNotFoundException above, FileNotFoundException is a subclass of IOException.
	 * @since 1.3
	 */
	public static FileInputStream openInputStream(@RUntainted final File file) throws IOException {
	    Objects.requireNonNull(file, "file");
	    return new FileInputStream(file);
	}

	/**
	 * Writes the {@code toString()} value of each item in a collection to
	 * the specified {@link File} line by line.
	 * The default VM encoding and the default line ending will be used.
	 *
	 * @param file  the file to write to
	 * @param lines the lines to write, {@code null} entries produce blank lines
	 * @throws IOException in case of an I/O error
	 * @since 1.3
	 */
	public static void writeLines(@RUntainted final File file, @RUntainted final Collection<?> lines) throws IOException {
	    writeLines(file, null, lines, null, false);
	}

	/**
	 * Writes the {@code toString()} value of each item in a collection to
	 * the specified {@link File} line by line.
	 * The default VM encoding and the specified line ending will be used.
	 *
	 * @param file       the file to write to
	 * @param lines      the lines to write, {@code null} entries produce blank lines
	 * @param lineEnding the line separator to use, {@code null} is system default
	 * @param append     if {@code true}, then the lines will be added to the
	 *                   end of the file rather than overwriting
	 * @throws IOException in case of an I/O error
	 * @since 2.1
	 */
	public static void writeLines(@RUntainted final File file, @RUntainted final Collection<?> lines, @RUntainted final String lineEnding, final boolean append) throws IOException {
	    writeLines(file, null, lines, lineEnding, append);
	}

	/**
	 * Writes the {@code toString()} value of each item in a collection to
	 * the specified {@link File} line by line, optionally appending.
	 * The specified character encoding and the default line ending will be used.
	 *
	 * @param file     the file to write to
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @param lines    the lines to write, {@code null} entries produce blank lines
	 * @param append   if {@code true}, then the lines will be added to the
	 *                 end of the file rather than overwriting
	 * @throws IOException                          in case of an I/O error
	 * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
	 * @since 2.1
	 */
	public static void writeLines(@RUntainted final File file, @RUntainted final String charsetName, @RUntainted final Collection<?> lines, final boolean append) throws IOException {
	    writeLines(file, charsetName, lines, null, append);
	}

	/**
	 * Copies a filtered directory to a new location.
	 * <p>
	 * This method copies the contents of the specified source directory to within the specified destination directory.
	 * </p>
	 * <p>
	 * The destination directory is created if it does not exist. If the destination directory did exist, then this
	 * method merges the source with the destination, with the source taking precedence.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the files' last
	 * modified date/times using {@link File#setLastModified(long)}, however it is not guaranteed that those operations
	 * will succeed. If the modification operation fails, the methods throws IOException.
	 * </p>
	 * <b>Example: Copy directories only</b>
	 *
	 * <pre>
	 * // only copy the directory structure
	 * FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY, false);
	 * </pre>
	 *
	 * <b>Example: Copy directories and txt files</b>
	 *
	 * <pre>
	 * // Create a filter for ".txt" files
	 * IOFileFilter txtSuffixFilter = FileFilterUtils.suffixFileFilter(".txt");
	 * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter);
	 *
	 * // Create a filter for either directories or ".txt" files
	 * FileFilter filter = FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles);
	 *
	 * // Copy using the filter
	 * FileUtils.copyDirectory(srcDir, destDir, filter, false);
	 * </pre>
	 *
	 * @param srcDir an existing directory to copy, must not be {@code null}
	 * @param destDir the new directory, must not be {@code null}
	 * @param fileFilter the filter to apply, null means copy all directories and files
	 * @param preserveFileDate true if the file date of the copy should be the same as the original
	 * @param copyOptions options specifying how the copy should be done, for example {@link StandardCopyOption}.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 2.8.0
	 */
	public static void copyDirectory(@RUntainted final File srcDir, @RUntainted final File destDir, @RUntainted final FileFilter fileFilter, final boolean preserveFileDate, @RUntainted final CopyOption... copyOptions) throws IOException {
	    requireFileCopy(srcDir, destDir);
	    requireDirectory(srcDir, "srcDir");
	    requireCanonicalPathsNotEquals(srcDir, destDir);
	    // Cater for destination being directory within the source directory (see IO-141)
	    List<String> exclusionList = null;
	    final String srcDirCanonicalPath = srcDir.getCanonicalPath();
	    final String destDirCanonicalPath = destDir.getCanonicalPath();
	    if (destDirCanonicalPath.startsWith(srcDirCanonicalPath)) {
	        final File[] srcFiles = listFiles(srcDir, fileFilter);
	        if (srcFiles.length > 0) {
	            exclusionList = new ArrayList<>(srcFiles.length);
	            for (final File srcFile : srcFiles) {
	                exclusionList.add(new File(destDir, srcFile.getName()).getCanonicalPath());
	            }
	        }
	    }
	    doCopyDirectory(srcDir, destDir, fileFilter, exclusionList, preserveFileDate, preserveFileDate ? addCopyAttributes(copyOptions) : copyOptions);
	}

	/**
	 * Writes a CharSequence to a file creating the file if it does not exist.
	 *
	 * @param file     the file to write
	 * @param data     the content to write to the file
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @param append   if {@code true}, then the data will be added to the
	 *                 end of the file rather than overwriting
	 * @throws IOException                 in case of an I/O error
	 * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
	 * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported by the VM
	 * @since 2.1
	 */
	public static void write(@RUntainted final File file, @RUntainted final CharSequence data, @RUntainted final String charsetName, final boolean append) throws IOException {
	    write(file, data, Charsets.toCharset(charsetName), append);
	}

	/**
	 * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.
	 *
	 * @param file   the file to write
	 * @param data   the content to write to the file
	 * @param append if {@code true}, then the String will be added to the
	 *               end of the file rather than overwriting
	 * @throws IOException in case of an I/O error
	 * @since 2.1
	 * @deprecated 2.5 use {@link #writeStringToFile(File, String, Charset, boolean)} instead (and specify the appropriate encoding)
	 */
	@Deprecated
	public static void writeStringToFile(@RUntainted final File file, @RUntainted final String data, final boolean append) throws IOException {
	    writeStringToFile(file, data, Charset.defaultCharset(), append);
	}

	/**
	 * Moves a directory.
	 * <p>
	 * When the destination directory is on another file system, do a "copy and delete".
	 * </p>
	 *
	 * @param srcDir the directory to be moved.
	 * @param destDir the destination directory.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.4
	 */
	public static void moveDirectory(@RUntainted final File srcDir, @RUntainted final File destDir) throws IOException {
	    validateMoveParameters(srcDir, destDir);
	    requireDirectory(srcDir, "srcDir");
	    requireAbsent(destDir, "destDir");
	    if (!srcDir.renameTo(destDir)) {
	        if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator)) {
	            throw new IOException("Cannot move directory: " + srcDir + " to a subdirectory of itself: " + destDir);
	        }
	        copyDirectory(srcDir, destDir);
	        deleteDirectory(srcDir);
	        if (srcDir.exists()) {
	            throw new IOException("Failed to delete original directory '" + srcDir + "' after copy to '" + destDir + "'");
	        }
	    }
	}

	/**
	 * Cleans a directory without deleting it.
	 *
	 * @param directory directory to clean
	 * @throws NullPointerException if the given {@link File} is {@code null}.
	 * @throws IllegalArgumentException if directory does not exist or is not a directory.
	 * @throws IOException if an I/O error occurs.
	 * @see #forceDelete(File)
	 */
	public static void cleanDirectory(@RUntainted final File directory) throws IOException {
	    IOConsumer.forAll(FileUtils::forceDelete, listFiles(directory, null));
	}

	/**
	 * Copies bytes from an {@link InputStream} {@code source} to a file
	 * {@code destination}. The directories up to {@code destination}
	 * will be created if they don't already exist. {@code destination}
	 * will be overwritten if it already exists.
	 * <p>
	 * <em>The {@code source} stream is closed.</em>
	 * </p>
	 * <p>
	 * See {@link #copyToFile(InputStream, File)} for a method that does not close the input stream.
	 * </p>
	 *
	 * @param source      the {@link InputStream} to copy bytes from, must not be {@code null}, will be closed
	 * @param destination the non-directory {@link File} to write bytes to
	 *                    (possibly overwriting), must not be {@code null}
	 * @throws IOException if {@code destination} is a directory
	 * @throws IOException if {@code destination} cannot be written
	 * @throws IOException if {@code destination} needs creating but can't be
	 * @throws IOException if an IO error occurs during copying
	 * @since 2.0
	 */
	public static void copyInputStreamToFile(@RUntainted final InputStream source, @RUntainted final File destination) throws IOException {
	    try (InputStream inputStream = source) {
	        copyToFile(inputStream, destination);
	    }
	}

	/**
	 * Copies a filtered directory to a new location preserving the file dates.
	 * <p>
	 * This method copies the contents of the specified source directory to within the specified destination directory.
	 * </p>
	 * <p>
	 * The destination directory is created if it does not exist. If the destination directory did exist, then this
	 * method merges the source with the destination, with the source taking precedence.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This method tries to preserve the files' last modified date/times using
	 * {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the
	 * modification operation fails, the methods throws IOException.
	 * </p>
	 * <b>Example: Copy directories only</b>
	 *
	 * <pre>
	 * // only copy the directory structure
	 * FileUtils.copyDirectory(srcDir, destDir, DirectoryFileFilter.DIRECTORY);
	 * </pre>
	 *
	 * <b>Example: Copy directories and txt files</b>
	 *
	 * <pre>
	 * // Create a filter for ".txt" files
	 * IOFileFilter txtSuffixFilter = FileFilterUtils.suffixFileFilter(".txt");
	 * IOFileFilter txtFiles = FileFilterUtils.andFileFilter(FileFileFilter.FILE, txtSuffixFilter);
	 *
	 * // Create a filter for either directories or ".txt" files
	 * FileFilter filter = FileFilterUtils.orFileFilter(DirectoryFileFilter.DIRECTORY, txtFiles);
	 *
	 * // Copy using the filter
	 * FileUtils.copyDirectory(srcDir, destDir, filter);
	 * </pre>
	 *
	 * @param srcDir an existing directory to copy, must not be {@code null}.
	 * @param destDir the new directory, must not be {@code null}.
	 * @param filter the filter to apply, null means copy all directories and files should be the same as the original.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.4
	 */
	public static void copyDirectory(@RUntainted final File srcDir, @RUntainted final File destDir, @RUntainted final FileFilter filter) throws IOException {
	    copyDirectory(srcDir, destDir, filter, true);
	}

	/**
	 * Moves a file.
	 * <p>
	 * When the destination file is on another file system, do a "copy and delete".
	 * </p>
	 *
	 * @param srcFile the file to be moved.
	 * @param destFile the destination file.
	 * @param copyOptions Copy options.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws FileExistsException if the destination file exists.
	 * @throws FileNotFoundException if the source file does not exist.
	 * @throws IOException if source or destination is invalid.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 2.9.0
	 */
	public static void moveFile(@RUntainted final File srcFile, @RUntainted final File destFile, @RUntainted final CopyOption... copyOptions) throws IOException {
	    validateMoveParameters(srcFile, destFile);
	    requireFile(srcFile, "srcFile");
	    requireAbsent(destFile, "destFile");
	    final boolean rename = srcFile.renameTo(destFile);
	    if (!rename) {
	        copyFile(srcFile, destFile, copyOptions);
	        if (!srcFile.delete()) {
	            FileUtils.deleteQuietly(destFile);
	            throw new IOException("Failed to delete original file '" + srcFile + "' after copy to '" + destFile + "'");
	        }
	    }
	}

	/**
	 * Copies a files to a directory preserving each file's date.
	 * <p>
	 * This method copies the contents of the specified source files
	 * to a file of the same name in the specified destination directory.
	 * The destination directory is created if it does not exist.
	 * If the destination file exists, then this method will overwrite it.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This method tries to preserve the file's last
	 * modified date/times using {@link File#setLastModified(long)}, however
	 * it is not guaranteed that the operation will succeed.
	 * If the modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param sourceIterable  existing files to copy, must not be {@code null}.
	 * @param destinationDir  the directory to place the copies in, must not be {@code null}.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IOException if source or destination is invalid.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @see #copyFileToDirectory(File, File)
	 * @since 2.6
	 */
	public static void copyToDirectory(@RUntainted final Iterable<File> sourceIterable, @RUntainted final File destinationDir) throws IOException {
	    Objects.requireNonNull(sourceIterable, "sourceIterable");
	    for (final File src : sourceIterable) {
	        copyFileToDirectory(src, destinationDir);
	    }
	}

	/**
	 * Schedules a file to be deleted when JVM exits.
	 * If file is directory delete it and all subdirectories.
	 *
	 * @param file file or directory to delete, must not be {@code null}.
	 * @throws NullPointerException if the file is {@code null}.
	 * @throws IOException          in case deletion is unsuccessful.
	 */
	public static void forceDeleteOnExit(@RUntainted final File file) throws IOException {
	    Objects.requireNonNull(file, "file");
	    if (file.isDirectory()) {
	        deleteDirectoryOnExit(file);
	    } else {
	        file.deleteOnExit();
	    }
	}

	/**
	 * Copies a file to a new location.
	 * <p>
	 * This method copies the contents of the specified source file to the specified destination file. The directory
	 * holding the destination file is created if it does not exist. If the destination file exists, you can overwrite
	 * it with {@link StandardCopyOption#REPLACE_EXISTING}.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
	 * modified date/times using {@link StandardCopyOption#COPY_ATTRIBUTES}, however it is not guaranteed that the operation
	 * will succeed. If the modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param srcFile an existing file to copy, must not be {@code null}.
	 * @param destFile the new file, must not be {@code null}.
	 * @param preserveFileDate true if the file date of the copy should be the same as the original.
	 * @param copyOptions options specifying how the copy should be done, for example {@link StandardCopyOption}..
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IllegalArgumentException if source is not a file.
	 * @throws IOException if the output file length is not the same as the input file length after the copy completes.
	 * @throws IOException if an I/O error occurs, or setting the last-modified time didn't succeed.
	 * @see #copyFileToDirectory(File, File, boolean)
	 * @since 2.8.0
	 */
	public static void copyFile(@RUntainted final File srcFile, @RUntainted final File destFile, final boolean preserveFileDate, @RUntainted final CopyOption... copyOptions) throws IOException {
	    copyFile(srcFile, destFile, preserveFileDate ? addCopyAttributes(copyOptions) : copyOptions);
	}

	/**
	 * Deletes a directory recursively.
	 *
	 * @param directory directory to delete
	 * @throws IOException              in case deletion is unsuccessful
	 * @throws NullPointerException     if the parameter is {@code null}
	 * @throws IllegalArgumentException if {@code directory} is not a directory
	 */
	public static void deleteDirectory(@RUntainted final File directory) throws IOException {
	    Objects.requireNonNull(directory, "directory");
	    if (!directory.exists()) {
	        return;
	    }
	    if (!isSymlink(directory)) {
	        cleanDirectory(directory);
	    }
	    delete(directory);
	}

	/**
	 * Writes the {@code toString()} value of each item in a collection to
	 * the specified {@link File} line by line.
	 * The default VM encoding and the default line ending will be used.
	 *
	 * @param file   the file to write to
	 * @param lines  the lines to write, {@code null} entries produce blank lines
	 * @param append if {@code true}, then the lines will be added to the
	 *               end of the file rather than overwriting
	 * @throws IOException in case of an I/O error
	 * @since 2.1
	 */
	public static void writeLines(@RUntainted final File file, @RUntainted final Collection<?> lines, final boolean append) throws IOException {
	    writeLines(file, null, lines, null, append);
	}

	/**
	 * Copies a file to a new location preserving the file date.
	 * <p>
	 * This method copies the contents of the specified source file to the specified destination file. The directory
	 * holding the destination file is created if it does not exist. If the destination file exists, then this method
	 * will overwrite it.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This method tries to preserve the file's last modified date/times using
	 * {@link StandardCopyOption#COPY_ATTRIBUTES}, however it is not guaranteed that the operation will succeed. If the
	 * modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param srcFile an existing file to copy, must not be {@code null}.
	 * @param destFile the new file, must not be {@code null}.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IOException if source or destination is invalid.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @throws IOException if the output file length is not the same as the input file length after the copy completes.
	 * @see #copyFileToDirectory(File, File)
	 * @see #copyFile(File, File, boolean)
	 */
	public static void copyFile(@RUntainted final File srcFile, @RUntainted final File destFile) throws IOException {
	    copyFile(srcFile, destFile, StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING);
	}

	/**
	 * Reads the contents of a file into a String using the default encoding for the VM.
	 * The file is always closed.
	 *
	 * @param file the file to read, must not be {@code null}
	 * @return the file contents, never {@code null}
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @since 1.3.1
	 * @deprecated 2.5 use {@link #readFileToString(File, Charset)} instead (and specify the appropriate encoding)
	 */
	@Deprecated
	public static String readFileToString(@RUntainted final File file) throws IOException {
	    return readFileToString(file, Charset.defaultCharset());
	}

	/**
	 * Copies bytes from the URL {@code source} to a file
	 * {@code destination}. The directories up to {@code destination}
	 * will be created if they don't already exist. {@code destination}
	 * will be overwritten if it already exists.
	 * <p>
	 * Warning: this method does not set a connection or read timeout and thus
	 * might block forever. Use {@link #copyURLToFile(URL, File, int, int)}
	 * with reasonable timeouts to prevent this.
	 * </p>
	 *
	 * @param source      the {@link URL} to copy bytes from, must not be {@code null}
	 * @param destination the non-directory {@link File} to write bytes to
	 *                    (possibly overwriting), must not be {@code null}
	 * @throws IOException if {@code source} URL cannot be opened
	 * @throws IOException if {@code destination} is a directory
	 * @throws IOException if {@code destination} cannot be written
	 * @throws IOException if {@code destination} needs creating but can't be
	 * @throws IOException if an IO error occurs during copying
	 */
	public static void copyURLToFile(@RUntainted final URL source, @RUntainted final File destination) throws IOException {
	    try (InputStream stream = source.openStream()) {
	        final Path path = destination.toPath();
	        PathUtils.createParentDirectories(path);
	        Files.copy(stream, path, StandardCopyOption.REPLACE_EXISTING);
	    }
	}

	/**
	 * Writes {@code len} bytes from the specified byte array starting
	 * at offset {@code off} to a file, creating the file if it does
	 * not exist.
	 *
	 * @param file   the file to write to
	 * @param data   the content to write to the file
	 * @param off    the start offset in the data
	 * @param len    the number of bytes to write
	 * @param append if {@code true}, then bytes will be added to the
	 *               end of the file rather than overwriting
	 * @throws IOException in case of an I/O error
	 * @since 2.5
	 */
	public static void writeByteArrayToFile(@RUntainted final File file, @RUntainted final byte[] data, final int off, final int len, final boolean append) throws IOException {
	    try (OutputStream out = newOutputStream(file, append)) {
	        out.write(data, off, len);
	    }
	}

	/**
	 * Copies a directory to within another directory preserving the file dates.
	 * <p>
	 * This method copies the source directory and all its contents to a directory of the same name in the specified
	 * destination directory.
	 * </p>
	 * <p>
	 * The destination directory is created if it does not exist. If the destination directory did exist, then this
	 * method merges the source with the destination, with the source taking precedence.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This method tries to preserve the files' last modified date/times using
	 * {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the
	 * modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param sourceDir an existing directory to copy, must not be {@code null}.
	 * @param destinationDir the directory to place the copy in, must not be {@code null}.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.2
	 */
	public static void copyDirectoryToDirectory(@RUntainted final File sourceDir, @RUntainted final File destinationDir) throws IOException {
	    requireDirectoryIfExists(sourceDir, "sourceDir");
	    requireDirectoryIfExists(destinationDir, "destinationDir");
	    copyDirectory(sourceDir, new File(destinationDir, sourceDir.getName()), true);
	}

	/**
	 * Returns an Iterator for the lines in a {@link File}.
	 * <p>
	 * This method opens an {@link InputStream} for the file.
	 * When you have finished with the iterator you should close the stream
	 * to free internal resources. This can be done by using a try-with-resources block or calling the
	 * {@link LineIterator#close()} method.
	 * </p>
	 * <p>
	 * The recommended usage pattern is:
	 * </p>
	 * <pre>
	 * LineIterator it = FileUtils.lineIterator(file, StandardCharsets.UTF_8.name());
	 * try {
	 *   while (it.hasNext()) {
	 *     String line = it.nextLine();
	 *     /// do something with line
	 *   }
	 * } finally {
	 *   LineIterator.closeQuietly(iterator);
	 * }
	 * </pre>
	 * <p>
	 * If an exception occurs during the creation of the iterator, the
	 * underlying stream is closed.
	 * </p>
	 *
	 * @param file     the file to open for input, must not be {@code null}
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @return a LineIterator for lines in the file, never {@code null}; MUST be closed by the caller.
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @since 1.2
	 */
	// Caller closes the result LineIterator.
	@SuppressWarnings("resource")
	public static LineIterator lineIterator(@RUntainted final File file, @RUntainted final String charsetName) throws IOException {
	    InputStream inputStream = null;
	    try {
	        inputStream = Files.newInputStream(file.toPath());
	        return IOUtils.lineIterator(inputStream, charsetName);
	    } catch (final IOException | RuntimeException ex) {
	        IOUtils.closeQuietly(inputStream, ex::addSuppressed);
	        throw ex;
	    }
	}

	/**
	 * Reads the contents of a file line by line to a List of Strings.
	 * The file is always closed.
	 *
	 * @param file     the file to read, must not be {@code null}
	 * @param charset the charset to use, {@code null} means platform default
	 * @return the list of Strings representing each line in the file, never {@code null}
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @since 2.3
	 */
	public static List<String> readLines(@RUntainted final File file, @RUntainted final Charset charset) throws IOException {
	    return Files.readAllLines(file.toPath(), charset);
	}

	/**
	 * Writes a CharSequence to a file creating the file if it does not exist.
	 *
	 * @param file     the file to write
	 * @param data     the content to write to the file
	 * @param charset the charset to use, {@code null} means platform default
	 * @param append   if {@code true}, then the data will be added to the
	 *                 end of the file rather than overwriting
	 * @throws IOException in case of an I/O error
	 * @since 2.3
	 */
	public static void write(@RUntainted final File file, @RUntainted final CharSequence data, @RUntainted final Charset charset, final boolean append) throws IOException {
	    writeStringToFile(file, Objects.toString(data, null), charset, append);
	}

	// Must be called with a directory
	/**
	 * Writes a byte array to a file creating the file if it does not exist.
	 * <p>
	 * NOTE: As from v1.3, the parent directories of the file will be created
	 * if they do not exist.
	 * </p>
	 *
	 * @param file the file to write to
	 * @param data the content to write to the file
	 * @throws IOException in case of an I/O error
	 * @since 1.1
	 */
	public static void writeByteArrayToFile(@RUntainted final File file, @RUntainted final byte[] data) throws IOException {
	    writeByteArrayToFile(file, data, false);
	}

	/**
	 * Writes the {@code toString()} value of each item in a collection to
	 * the specified {@link File} line by line.
	 * The specified character encoding and the line ending will be used.
	 *
	 * @param file       the file to write to
	 * @param charsetName   the name of the requested charset, {@code null} means platform default
	 * @param lines      the lines to write, {@code null} entries produce blank lines
	 * @param lineEnding the line separator to use, {@code null} is system default
	 * @param append     if {@code true}, then the lines will be added to the
	 *                   end of the file rather than overwriting
	 * @throws IOException                          in case of an I/O error
	 * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
	 * @since 2.1
	 */
	public static void writeLines(@RUntainted final File file, @RUntainted final String charsetName, @RUntainted final Collection<?> lines, @RUntainted final String lineEnding, final boolean append) throws IOException {
	    try (OutputStream out = new BufferedOutputStream(newOutputStream(file, append))) {
	        IOUtils.writeLines(lines, lineEnding, out, charsetName);
	    }
	}

	/**
	 * Reads the contents of a file line by line to a List of Strings. The file is always closed.
	 *
	 * @param file     the file to read, must not be {@code null}
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @return the list of Strings representing each line in the file, never {@code null}
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
	 * .UnsupportedEncodingException} in version 2.2 if the named charset is unavailable.
	 * @since 1.1
	 */
	public static List<String> readLines(@RUntainted final File file, @RUntainted final String charsetName) throws IOException {
	    return readLines(file, Charsets.toCharset(charsetName));
	}

	/**
	 * Deletes a file or directory. For a directory, delete it and all subdirectories.
	 * <p>
	 * The difference between File.delete() and this method are:
	 * </p>
	 * <ul>
	 * <li>The directory does not have to be empty.</li>
	 * <li>You get an exception when a file or directory cannot be deleted.</li>
	 * </ul>
	 *
	 * @param file file or directory to delete, must not be {@code null}.
	 * @throws NullPointerException  if the file is {@code null}.
	 * @throws FileNotFoundException if the file was not found.
	 * @throws IOException           in case deletion is unsuccessful.
	 */
	public static void forceDelete(@RUntainted final File file) throws IOException {
	    Objects.requireNonNull(file, "file");
	    final Counters.PathCounters deleteCounters;
	    try {
	        deleteCounters = PathUtils.delete(file.toPath(), PathUtils.EMPTY_LINK_OPTION_ARRAY, StandardDeleteOption.OVERRIDE_READ_ONLY);
	    } catch (final IOException e) {
	        throw new IOException("Cannot delete file: " + file, e);
	    }
	    if (deleteCounters.getFileCounter().get() < 1 && deleteCounters.getDirectoryCounter().get() < 1) {
	        // didn't find a file to delete.
	        throw new FileNotFoundException("File does not exist: " + file);
	    }
	}

	/**
	 * Deletes a file, never throwing an exception. If file is a directory, delete it and all subdirectories.
	 * <p>
	 * The difference between File.delete() and this method are:
	 * </p>
	 * <ul>
	 * <li>A directory to be deleted does not have to be empty.</li>
	 * <li>No exceptions are thrown when a file or directory cannot be deleted.</li>
	 * </ul>
	 *
	 * @param file file or directory to delete, can be {@code null}
	 * @return {@code true} if the file or directory was deleted, otherwise
	 * {@code false}
	 * @since 1.4
	 */
	public static boolean deleteQuietly(@RUntainted final File file) {
	    if (file == null) {
	        return false;
	    }
	    try {
	        if (file.isDirectory()) {
	            cleanDirectory(file);
	        }
	    } catch (final Exception ignored) {
	        // ignore
	    }
	    try {
	        return file.delete();
	    } catch (final Exception ignored) {
	        return false;
	    }
	}

	/**
	 * Returns an Iterator for the lines in a {@link File} using the default encoding for the VM.
	 *
	 * @param file the file to open for input, must not be {@code null}
	 * @return an Iterator of the lines in the file, never {@code null}
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @see #lineIterator(File, String)
	 * @since 1.3
	 */
	public static LineIterator lineIterator(@RUntainted final File file) throws IOException {
	    return lineIterator(file, null);
	}

	/**
	 * Writes the {@code toString()} value of each item in a collection to
	 * the specified {@link File} line by line.
	 * The specified character encoding and the line ending will be used.
	 * <p>
	 * NOTE: As from v1.3, the parent directories of the file will be created
	 * if they do not exist.
	 * </p>
	 *
	 * @param file       the file to write to
	 * @param charsetName   the name of the requested charset, {@code null} means platform default
	 * @param lines      the lines to write, {@code null} entries produce blank lines
	 * @param lineEnding the line separator to use, {@code null} is system default
	 * @throws IOException                          in case of an I/O error
	 * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
	 * @since 1.1
	 */
	public static void writeLines(@RUntainted final File file, @RUntainted final String charsetName, @RUntainted final Collection<?> lines, @RUntainted final String lineEnding) throws IOException {
	    writeLines(file, charsetName, lines, lineEnding, false);
	}

	/**
	 * Copies a file to a new location.
	 * <p>
	 * This method copies the contents of the specified source file to the specified destination file. The directory
	 * holding the destination file is created if it does not exist. If the destination file exists, you can overwrite
	 * it if you use {@link StandardCopyOption#REPLACE_EXISTING}.
	 * </p>
	 *
	 * @param srcFile an existing file to copy, must not be {@code null}.
	 * @param destFile the new file, must not be {@code null}.
	 * @param copyOptions options specifying how the copy should be done, for example {@link StandardCopyOption}..
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IllegalArgumentException if source is not a file.
	 * @throws IOException if an I/O error occurs.
	 * @see StandardCopyOption
	 * @since 2.9.0
	 */
	public static void copyFile(@RUntainted final File srcFile, @RUntainted final File destFile, @RUntainted final CopyOption... copyOptions) throws IOException {
	    requireFileCopy(srcFile, destFile);
	    requireFile(srcFile, "srcFile");
	    requireCanonicalPathsNotEquals(srcFile, destFile);
	    createParentDirectories(destFile);
	    requireFileIfExists(destFile, "destFile");
	    if (destFile.exists()) {
	        requireCanWrite(destFile, "destFile");
	    }
	    // On Windows, the last modified time is copied by default.
	    Files.copy(srcFile.toPath(), destFile.toPath(), copyOptions);
	}

	/**
	 * Writes a String to a file creating the file if it does not exist using the default encoding for the VM.
	 *
	 * @param file the file to write
	 * @param data the content to write to the file
	 * @throws IOException in case of an I/O error
	 * @deprecated 2.5 use {@link #writeStringToFile(File, String, Charset)} instead (and specify the appropriate encoding)
	 */
	@Deprecated
	public static void writeStringToFile(@RUntainted final File file, @RUntainted final String data) throws IOException {
	    writeStringToFile(file, data, Charset.defaultCharset(), false);
	}

	/**
	 * Copies bytes from a {@link File} to an {@link OutputStream}.
	 * <p>
	 * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.
	 * </p>
	 *
	 * @param input  the {@link File} to read.
	 * @param output the {@link OutputStream} to write.
	 * @return the number of bytes copied
	 * @throws NullPointerException if the File is {@code null}.
	 * @throws NullPointerException if the OutputStream is {@code null}.
	 * @throws IOException          if an I/O error occurs.
	 * @since 2.1
	 */
	public static long copyFile(@RUntainted final File input, @RUntainted final OutputStream output) throws IOException {
	    try (InputStream fis = Files.newInputStream(input.toPath())) {
	        return IOUtils.copyLarge(fis, output);
	    }
	}

	/**
	 * Writes a String to a file creating the file if it does not exist.
	 * <p>
	 * NOTE: As from v1.3, the parent directories of the file will be created
	 * if they do not exist.
	 * </p>
	 *
	 * @param file     the file to write
	 * @param data     the content to write to the file
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @throws IOException                          in case of an I/O error
	 * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
	 */
	public static void writeStringToFile(@RUntainted final File file, @RUntainted final String data, @RUntainted final String charsetName) throws IOException {
	    writeStringToFile(file, data, charsetName, false);
	}

	/**
	 * Reads the contents of a file into a String. The file is always closed.
	 *
	 * @param file     the file to read, must not be {@code null}
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @return the file contents, never {@code null}
	 * @throws NullPointerException if file is {@code null}.
	 * @throws FileNotFoundException if the file does not exist, is a directory rather than a regular file, or for some
	 *         other reason cannot be opened for reading.
	 * @throws IOException if an I/O error occurs.
	 * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io
	 * .UnsupportedEncodingException} in version 2.2 if the named charset is unavailable.
	 * @since 2.3
	 */
	public static String readFileToString(@RUntainted final File file, @RUntainted final String charsetName) throws IOException {
	    return readFileToString(file, Charsets.toCharset(charsetName));
	}

	/**
	 * Copies a whole directory to a new location preserving the file dates.
	 * <p>
	 * This method copies the specified directory and all its child directories and files to the specified destination.
	 * The destination is the new location and name of the directory.
	 * </p>
	 * <p>
	 * The destination directory is created if it does not exist. If the destination directory did exist, then this
	 * method merges the source with the destination, with the source taking precedence.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This method tries to preserve the files' last modified date/times using
	 * {@link File#setLastModified(long)}, however it is not guaranteed that those operations will succeed. If the
	 * modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param srcDir an existing directory to copy, must not be {@code null}.
	 * @param destDir the new directory, must not be {@code null}.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.1
	 */
	public static void copyDirectory(@RUntainted final File srcDir, @RUntainted final File destDir) throws IOException {
	    copyDirectory(srcDir, destDir, true);
	}

	/**
	 * Copies an existing file to a new file location.
	 * <p>
	 * This method copies the contents of the specified source file to the specified destination file. The directory
	 * holding the destination file is created if it does not exist. If the destination file exists, then this method
	 * will overwrite it.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the file's last
	 * modified date/times using {@link StandardCopyOption#COPY_ATTRIBUTES}, however it is not guaranteed that the operation
	 * will succeed. If the modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param srcFile an existing file to copy, must not be {@code null}.
	 * @param destFile the new file, must not be {@code null}.
	 * @param preserveFileDate true if the file date of the copy should be the same as the original.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IOException if source or destination is invalid.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @throws IOException if the output file length is not the same as the input file length after the copy completes
	 * @see #copyFile(File, File, boolean, CopyOption...)
	 */
	public static void copyFile(@RUntainted final File srcFile, @RUntainted final File destFile, final boolean preserveFileDate) throws IOException {
	    // @formatter:off
	    copyFile(srcFile, destFile, preserveFileDate ? new CopyOption[] { StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING } : new CopyOption[] { StandardCopyOption.REPLACE_EXISTING });
	    // @formatter:on
	}

	/**
	 * Writes the {@code toString()} value of each item in a collection to
	 * the specified {@link File} line by line.
	 * The default VM encoding and the specified line ending will be used.
	 *
	 * @param file       the file to write to
	 * @param lines      the lines to write, {@code null} entries produce blank lines
	 * @param lineEnding the line separator to use, {@code null} is system default
	 * @throws IOException in case of an I/O error
	 * @since 1.3
	 */
	public static void writeLines(@RUntainted final File file, @RUntainted final Collection<?> lines, @RUntainted final String lineEnding) throws IOException {
	    writeLines(file, null, lines, lineEnding, false);
	}

	/**
	 * Moves a file preserving attributes.
	 * <p>
	 * Shorthand for {@code moveFile(srcFile, destFile, StandardCopyOption.COPY_ATTRIBUTES)}.
	 * </p>
	 * <p>
	 * When the destination file is on another file system, do a "copy and delete".
	 * </p>
	 *
	 * @param srcFile the file to be moved.
	 * @param destFile the destination file.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws FileExistsException if the destination file exists.
	 * @throws FileNotFoundException if the source file does not exist.
	 * @throws IOException if source or destination is invalid.
	 * @throws IOException if an error occurs.
	 * @since 1.4
	 */
	public static void moveFile(@RUntainted final File srcFile, @RUntainted final File destFile) throws IOException {
	    moveFile(srcFile, destFile, StandardCopyOption.COPY_ATTRIBUTES);
	}

	/**
	 * Copies a whole directory to a new location.
	 * <p>
	 * This method copies the contents of the specified source directory to within the specified destination directory.
	 * </p>
	 * <p>
	 * The destination directory is created if it does not exist. If the destination directory did exist, then this
	 * method merges the source with the destination, with the source taking precedence.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> Setting {@code preserveFileDate} to {@code true} tries to preserve the files' last
	 * modified date/times using {@link File#setLastModified(long)}, however it is not guaranteed that those operations
	 * will succeed. If the modification operation fails, the methods throws IOException.
	 * </p>
	 *
	 * @param srcDir an existing directory to copy, must not be {@code null}.
	 * @param destDir the new directory, must not be {@code null}.
	 * @param preserveFileDate true if the file date of the copy should be the same as the original.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.1
	 */
	public static void copyDirectory(@RUntainted final File srcDir, @RUntainted final File destDir, final boolean preserveFileDate) throws IOException {
	    copyDirectory(srcDir, destDir, null, preserveFileDate);
	}

	/**
	 * Writes a byte array to a file creating the file if it does not exist.
	 *
	 * @param file   the file to write to
	 * @param data   the content to write to the file
	 * @param append if {@code true}, then bytes will be added to the
	 *               end of the file rather than overwriting
	 * @throws IOException in case of an I/O error
	 * @since 2.1
	 */
	public static void writeByteArrayToFile(@RUntainted final File file, @RUntainted final byte[] data, final boolean append) throws IOException {
	    writeByteArrayToFile(file, data, 0, data.length, append);
	}

	/**
	 * Writes a CharSequence to a file creating the file if it does not exist.
	 *
	 * @param file     the file to write
	 * @param data     the content to write to the file
	 * @param charsetName the name of the requested charset, {@code null} means platform default
	 * @throws IOException                          in case of an I/O error
	 * @throws java.io.UnsupportedEncodingException if the encoding is not supported by the VM
	 * @since 2.0
	 */
	public static void write(@RUntainted final File file, @RUntainted final CharSequence data, @RUntainted final String charsetName) throws IOException {
	    write(file, data, charsetName, false);
	}

	/**
	 * Opens a {@link FileOutputStream} for the specified file, checking and
	 * creating the parent directory if it does not exist.
	 * <p>
	 * At the end of the method either the stream will be successfully opened,
	 * or an exception will have been thrown.
	 * </p>
	 * <p>
	 * The parent directory will be created if it does not exist.
	 * The file will be created if it does not exist.
	 * An exception is thrown if the file object exists but is a directory.
	 * An exception is thrown if the file exists but cannot be written to.
	 * An exception is thrown if the parent directory cannot be created.
	 * </p>
	 *
	 * @param file the file to open for output, must not be {@code null}
	 * @return a new {@link FileOutputStream} for the specified file
	 * @throws NullPointerException if the file object is {@code null}.
	 * @throws IllegalArgumentException if the file object is a directory
	 * @throws IllegalArgumentException if the file is not writable.
	 * @throws IOException if the directories could not be created.
	 * @since 1.3
	 */
	public static FileOutputStream openOutputStream(@RUntainted final File file) throws IOException {
	    return openOutputStream(file, false);
	}

	/**
	 * Moves a file to a directory.
	 *
	 * @param srcFile the file to be moved.
	 * @param destDir the destination file.
	 * @param createDestDir If {@code true} create the destination directory, otherwise if {@code false} throw an
	 *        IOException.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws FileExistsException if the destination file exists.
	 * @throws FileNotFoundException if the source file does not exist.
	 * @throws IOException if source or destination is invalid.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @since 1.4
	 */
	public static void moveFileToDirectory(@RUntainted final File srcFile, @RUntainted final File destDir, final boolean createDestDir) throws IOException {
	    validateMoveParameters(srcFile, destDir);
	    if (!destDir.exists() && createDestDir) {
	        mkdirs(destDir);
	    }
	    requireExistsChecked(destDir, "destDir");
	    requireDirectory(destDir, "destDir");
	    moveFile(srcFile, new File(destDir, srcFile.getName()));
	}

	/**
	 * Writes a String to a file creating the file if it does not exist.
	 *
	 * @param file     the file to write
	 * @param data     the content to write to the file
	 * @param charset the charset to use, {@code null} means platform default
	 * @param append   if {@code true}, then the String will be added to the
	 *                 end of the file rather than overwriting
	 * @throws IOException in case of an I/O error
	 * @since 2.3
	 */
	public static void writeStringToFile(@RUntainted final File file, @RUntainted final String data, @RUntainted final Charset charset, final boolean append) throws IOException {
	    try (OutputStream out = newOutputStream(file, append)) {
	        IOUtils.write(data, out, charset);
	    }
	}

	/**
	 * Writes a CharSequence to a file creating the file if it does not exist using the default encoding for the VM.
	 *
	 * @param file the file to write
	 * @param data the content to write to the file
	 * @throws IOException in case of an I/O error
	 * @since 2.0
	 * @deprecated 2.5 use {@link #write(File, CharSequence, Charset)} instead (and specify the appropriate encoding)
	 */
	@Deprecated
	public static void write(@RUntainted final File file, @RUntainted final CharSequence data) throws IOException {
	    write(file, data, Charset.defaultCharset(), false);
	}

	/**
	 * Copies a file or directory to within another directory preserving the file dates.
	 * <p>
	 * This method copies the source file or directory, along all its contents, to a directory of the same name in the
	 * specified destination directory.
	 * </p>
	 * <p>
	 * The destination directory is created if it does not exist. If the destination directory did exist, then this method
	 * merges the source with the destination, with the source taking precedence.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This method tries to preserve the files' last modified date/times using
	 * {@link StandardCopyOption#COPY_ATTRIBUTES} or {@link File#setLastModified(long)} depending on the input, however it
	 * is not guaranteed that those operations will succeed. If the modification operation fails, the methods throws
	 * IOException.
	 * </p>
	 *
	 * @param sourceFile an existing file or directory to copy, must not be {@code null}.
	 * @param destinationDir the directory to place the copy in, must not be {@code null}.
	 * @throws NullPointerException if any of the given {@link File}s are {@code null}.
	 * @throws IllegalArgumentException if the source or destination is invalid.
	 * @throws FileNotFoundException if the source does not exist.
	 * @throws IOException if an error occurs or setting the last-modified time didn't succeed.
	 * @see #copyDirectoryToDirectory(File, File)
	 * @see #copyFileToDirectory(File, File)
	 * @since 2.6
	 */
	public static void copyToDirectory(@RUntainted final File sourceFile, @RUntainted final File destinationDir) throws IOException {
	    Objects.requireNonNull(sourceFile, "sourceFile");
	    if (sourceFile.isFile()) {
	        copyFileToDirectory(sourceFile, destinationDir);
	    } else if (sourceFile.isDirectory()) {
	        copyDirectoryToDirectory(sourceFile, destinationDir);
	    } else {
	        throw new FileNotFoundException("The source " + sourceFile + " does not exist");
	    }
	}

	/**
	 * Writes {@code len} bytes from the specified byte array starting
	 * at offset {@code off} to a file, creating the file if it does
	 * not exist.
	 *
	 * @param file the file to write to
	 * @param data the content to write to the file
	 * @param off  the start offset in the data
	 * @param len  the number of bytes to write
	 * @throws IOException in case of an I/O error
	 * @since 2.5
	 */
	public static void writeByteArrayToFile(@RUntainted final File file, @RUntainted final byte[] data, final int off, final int len) throws IOException {
	    writeByteArrayToFile(file, data, off, len, false);
	}

	/**
	 * Copies bytes from an {@link InputStream} source to a {@link File} destination. The directories
	 * up to {@code destination} will be created if they don't already exist. {@code destination} will be
	 * overwritten if it already exists. The {@code source} stream is left open, e.g. for use with
	 * {@link java.util.zip.ZipInputStream ZipInputStream}. See {@link #copyInputStreamToFile(InputStream, File)} for a
	 * method that closes the input stream.
	 *
	 * @param inputStream the {@link InputStream} to copy bytes from, must not be {@code null}
	 * @param file the non-directory {@link File} to write bytes to (possibly overwriting), must not be
	 *        {@code null}
	 * @throws NullPointerException if the InputStream is {@code null}.
	 * @throws NullPointerException if the File is {@code null}.
	 * @throws IllegalArgumentException if the file object is a directory.
	 * @throws IllegalArgumentException if the file is not writable.
	 * @throws IOException if the directories could not be created.
	 * @throws IOException if an IO error occurs during copying.
	 * @since 2.5
	 */
	public static void copyToFile(@RUntainted final InputStream inputStream, @RUntainted final File file) throws IOException {
	    try (OutputStream out = newOutputStream(file, false)) {
	        IOUtils.copy(inputStream, out);
	    }
	}

}
